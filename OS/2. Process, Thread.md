# Process, Thread
======

## 프로그램

파일이 저장 장치에만 있고, 메모리엔 올라가지 않은 정적인 상태
즉, 아직 실행되지 않은 파일을 의미한다.


## 프로세스

프로세스는 컴퓨터 시스템에서 실행 중인 프로그램의 인스턴스입니다.
즉, 메모리에 올라가 있는 상태에서 프로그램이 작동하고 있는 것을
프로세스라고 합니다. 운영 체제는 필요한 코드 및 자원을 할당하고
실행, 관리를 수행합니다. 또한 프로세스의 상태를 관리하며 이러한
구현을 위해 운영 체제는 시분할 스케줄링, 프로세스 간 통신(IPC),
동기화 등의 다양한 기법을 사용합니다.

- 코드(Code) 영역 : 프로그램의 실행 명령어들이 저장되어 있는 부분으로,
  CPU가 차례대로 명령어를 수행합니다.

- 데이터(Data) 영역 : 전역 변수와 정적 변수가 저장되는 영역으로 프로세스의
  실행 도중 변할 수 있는 데이터입니다.

- 스택(Stack) 영역 : 함수 호출과 로컬 변수에 대한 정보가 저장되는 영역으로
  함수의 호출과 리턴을 관리하는데 사용됩니다.

- 힙(Heap) 영역 : 동적으로 할당된 메모리 영역으로 프로그램 실행 중 필요할
  때 메모리를 할당하고 해제하는데 사용됩니다.


## 쓰레드

쓰레드는 프로세스 내에서 실행되는 작은 실행 단위입니다. 쓰레드는 부모
프로세스의 메모리 공간과 자원을 공유하므로 프로세스에 비해 자원 소모가
적습니다. 각 쓰레드는 독립적인 스택, 레지스터 집합, 프로그램 카운터를
갖고있어 독립적인 작업을 수행 할 수 있습니다.

- 쓰레드 ID : 각 쓰레드는 운영 체제에서 고유한 식별자를 부여받습니다.
  이를 통해 운영 체제는 쓰레드를 구분하고 관리합니다.

- 프로세스 정보 : 쓰레드는 부모 프로세스의 메모리, 자원, 코드 영역 등을
  공유합니다. 이를 통해 프로세스는 자원을 효율적으로 사용할 수 있습니다.

- 레지스터 집합 : 각 쓰레드는 별도의 레지스터 집합을 가지고 있어 독립적인
  작업을 수행할 수 있습니다. 이에 따라 쓰레드 간 컨텍스트 스위칭이
  빠릅니다.

- 스택 : 각 쓰레드는 독립적인 스택 영역을 가지고 있어 함수 호출 및 로컬
  변수에 대한 정보를 담당합니다.


## 컨텍스트 스위칭(Context Switching)

컨텍스트 스위칭은 운영 체제의 일부로, 여러 프로세스 또는 쓰레드 간
실행을 전환하는 과정입니다. 컨텍스트 스위칭은 CPU가 한 작업에서 다른
작업으로 바뀌어 진행할 수 있도록 도와주며, 다중 프로세싱 시스템에서
핵심적인 역할을 수행합니다. 이는 시스템에서 중요한 역할을 수행하며
다중 작업을 가능하게 해줍니다.

하지만 일정한 오버헤드가 발생하며 시스템 성능에 영향을 줄 수있습니다.
오버헤드를 줄이기 위해선 적절한 알고리즘 및 기술 사용, 코드 최적화
및 재사용으로 효율을 높여 오버헤드를 줄일 수 있습니다.


- 오버헤드 : 컴퓨팅에서 필요한 작업 혹은 제어 정보와 관련된 부가적인
  처리 또는 비용을 의미합니다. 이는 작업을 수행하거나 정보 전송에 있어
  기본적인 작업 외에 추가적인 노력을 포함합니다. 컨텍스트 스위칭에서의
  오버헤드는 멀티태스킹 시스템에서 작업 간 전환을 수행하며 발생하는
  부가적인 시간 및 자원을 오버헤드라고 합니다. (상태 저장, 로드, 복원 등)


## 멀티 프로세스

멀티 프로세스는 여러 개의 프로세스가 동시에 실행되는 컴퓨팅 방식입니다.
이 방식에서 각 프로세스는 독립된 메모리 공간과 시스템 자원을 사용하며
운영 체제가 각 프로세스를 개별적으로 관리합니다. 멀티 프로세스는 동시에
여러 작업을 수행하고자 할 때 사용되며 컴퓨팅 시스템의 전체 처리 능력을
향상시키는 데 도움이 됩니다.

- 각 프로세스는 독립된 실행 환경을 갖습니다.

- 프로세스는 서로 다른 메모리 공간 및 자원을 사용하여 간섭 없이
  실행할 수 있습니다.

- 운영 체제는 프로세스 간의 메모리 보호를 제공합니다.

멀티 프로세스의 이점은 하나의 프로세스가 충돌하더라도 다른 프로세스에
영향을 주지 않아 시스템의 안정성이 향상될 수 있습니다. 하지만 메모리
사용량과 관리 비용이 높습니다. 각 프로세스는 독립된 메모리를 사용하므로
불필요한 메모리 중복이 발생할 수 있습니다. 프로세스 간의 통신이 복잡합니다.
프로세스 간 데이터를 주고받기 위해선 IPC(Inter-Process Communication)
기법이 사용되며 이에 대한 추가 구현이 요구됩니다.


## 멀티 쓰레드

멀티 쓰레드는 하나의 프로세스 내에서 여러 개의 작업 단위인 쓰레드가
동시에 실행되는 방식입니다. 멀티 쓰레드는 각 쓰레드가 부모 프로세스의
자원과 메모리 공간을 공유하기 때문에 멀티 프로세스에 비해 메모리와
시스템 자원 소모가 적습니다.

- 여러 쓰레드가 프로세스의 메모리 및 자원을 공유합니다.

- 각 쓰레드는 독립적인 작업을 수행 할 수 있는 레지스터 집합, 스택,
  프로그램 카운터를 가집니다.

멀티 쓰레드의 이점은 메모리 사용량이 적고 시스템 자원을 효율적으로
활용할 수 있습니다. 공유 자원을 활용하면 쓰레드 간 데이터 전송이 쉬워
쓰레드 간 통신이 간단합니다. 또한 각 쓰레드는 레지스터 집합과 스택만
변경하면 되므로 쓰레드 간의 컨텍스트 스위칭 속도가 빠릅니다.
하지만 여러 쓰레드가 동시에 공유 자원에 접근할때 동기화 문제가 발생할
수 있습니다. 또한 한 쓰레드가 충돌하거나 문제가 생기면 동일한 프로세스
내의 다른 쓰레드에도 영향을 줄 수 있습니다.


멀티 프로세스는 자원의 독립성과 안정성이 중요한 상황에 적합합니다. 반면에
멀티 쓰레드 방식은 높은 효율성과 응답성이 필요한 경우에 적합합니다.
작업의 특성, 요구 사항에 따라 멀티 프로세스와 멀티 쓰레드 중 적절한 방식을
선택해야 합니다.


## 교착상태(Dead Lock)

교착상태(Dead Lock)은 컴퓨터 시스템에서 자원을 할당하는 과정에서 발생할
수 있는 문제 중 하나입니다. 데드락에서 프로세스들은 서로 필요한 자원을
소유하며 대기하는 상태에 빠지게 되어 서로 진행이 불가능한 상태를 의미합니다.
이는 운영체제에서 중요한 이슈이며 효율적인 자원 활용과 시스템 성능 관리를
위해 데드락을 방지하거나 해결하는 기법들이 많이 연구되어 왔습니다.

교착상태가 발생하기 위해선 4가지 조건이 만족되어야 합니다.

- 상호 배제(Mutual Exclusion): 자원이 한번에 한 프로세스에 의해서만
  사용될 수 있는 경우

- 점유와 대기(Hold and Wait): 프로세스가 하나 이상의 자원을 점유한 상태에서
  다른 프로세스가 사용하고 있는 자원의 반환을 기다리는 경우

- 비선점(No Preemption): 다른 프로세스의 자원을 강제로 빼앗아오지 않는 경우

- 순환 대기(Circular Wait): 프로세스들이 서로 순환 형태로 대기하는 경우
  

## 교착상태 대처법

데드락에 대한 해결방안은 크게 4가지로 나눌 수 있습니다.


### 예방(Prevention)

데드락 예방은 데드락 발생조건 중 하나 이상을 제거하여 데드락이 발생 할 수
없도록 만드는 방법입니다.

- 상호 배제: 상호 배제는 오직 한 프로세스만 자원을 사용할 수있는 상황입니다.
  이 조건을 제거하기 위해선 공유 가능한 자원을 사용하거나, 자원의 전용 사용을
  최소화할 수 있습니다.

- 점유와 대기: 점유와 대기는 이미 어떤 자원을 점유한 상태에서 다른 자원을
  기다리는 상황입니다. 이 조건을 제거하는 방법 중 하나는 프로세스가 실행되기 전에
  모든 필요한 자원을 한번에 요청하는 것입니다. 또 다른 방법은 프로세스가 이미
  실질적으로 필요한 자원만 점유하도록 하거나, 필요한 자원이 모두 사용 가능할 때까지
  기다린 후 한꺼번에 점유하도록 하는 것입니다.

- 비선점: 비선점은 프로세스가 점유하고 있는 자원을 다른 프로세스에게 양보하지
  않는 상황입니다. 이 조건을 제거하기 위해선 자원이 필요한 프로세스에게 이미
  점유된 자원을 양보하도록 하거나 필요한 경우 강제로 반환할 수 있도록 허용해야
  합니다. 단 이 방법은 자원 선점 과정에서 오버헤드가 발생할 수 있고, 실행 중인
  프로세스에 영향을 줄 수 있음을 유의해야 합니다.

- 순환 대기: 순환 대기는 여러 프로세스가 서로 순환 형태로 자원을 기다리는 상황
  입니다. 이 조건을 제거하기 위해선 자원에 고유한 번호를 할당하고, 프로세스가
  번호 순서대로 자원을 요청하도록 하는 방법이 있습니다. 이렇게 하면 자원을 기다
  리는 프로세스들 사이에 선형적인 순서가 생기게 되어 순환 대기 조건을 방지할 수
  있습니다.


### 회피(Avoidance)

데드락 회피는 데드락이 발생할 위험을 감지하고 위험을 피하여 시스템이 안전한 상태를
유지하도 자원을 할당하는 방법입니다. 즉 데드락을 사전에 예방하는 것이 아니라 데드
락이 발생할 가능성이 있는 상황에서 회피하는 방식입니다. 이를 위해 운영 체제는 각
프로세스로부터 필요한 자원 정보와 시스템 전체 자원 할당 상태를 파악하고 관리합니다.
데드락 회피의 가장 대표적인 방법은 '은행원 알고리즘'입니다. 이 알고리즘은 프로세스의
자원 요규량, 가용한 자원 등의 정보를 기반으로 안전한 상태를 유지하며 자원을 할당합
니다.

은행원 알고리즘의 핵심 개념은 안전 상태와 위험 상태를 확인하는 것입니다.
알고리즘의 흐름은 다음과 같습니다.

- 프로세스는 필요한 자원의 양을 시스템에 요청합니다.

- 시스템은 요청된 자원을 할당해도 안전 상태를 유지할 수 있는지 확인합니다.

- 시스템이 안전 상태를 유지할 수 있다면 요청된 자원을 프로세스에 할당합니다.
  그렇지 않으면 자원을 할당하지 않고 프로세스를 대기 상태로 둡니다.

안전한 상태는 요청된 자원이 할당된 후에도 프로세스가 완료될 수 있는 충분한 자원이
남아있는지 확인함으로써 이루어집니다.

데드락 회피는 데드락 발생 가능성이 높고 시스템의 안정성이 중요한 환경에서 고려 될
수 있습니다. 그러나 시스템의 자원 관리가 복잡해지고 높은 오버헤드가 발생하게 되며
프로세스의 최대 자원 요청량을 파악하여야 하는데 현실적으로 어려운 경우가 많습니다.
또한 어떤 경우에는 사용되지 않고 남는 자원이 존재할 수 있어 효율이 떨어질 수 있습니다.


### 탐지 및 복구(Detection and Recovery)

데드락 검출은 시스템에서 데드락이 발생했는지 탐지하는 알고리즘입니다. 이를 위해
자원 할당 그래프와 같은 기법을 이용하여 순환 대기 상태를 찾습니다.

자원 할당 그래프는 시스템에서 프로세스와 자원 간의 자원 할당 상태를 시각화하는
유효한 도구입니다.

- 노드: 그래프 내 노드는 프로세스 또는 자원을 나타냅니다. 자원 노드는 한개 이상의
  인스턴스를 가질 수 있습니다.

- 할당 엣지: 자원 노드에서 프로세스 노드 방향을 가진 엣지로 특정 자원이 프로세스에
  할당된 것을 나타냅니다.

- 요청 엣지: 프로세스 노드에서 자원 노드 방향을 가진 엣지로 프로세스가 자원을 요청
  하는 것을 나타냅니다.

그래프 내에서 순환 구조를 찾습니다. 순환 구조가 존재하면 해당 사이클에서 프로세스와
자원 사이에 교착 상태가 발생한 것으로 간주할 수 있습니다. 그러나 이 방법은 다중 인스
턴스 자원에선 교착 상태 판단이 정확하지 않을 수 있습니다.

데드락 복구는 데드락이 발생한 것을 확인한 후에 적절한 복구 방법을 통해 시스템을 정상
상태로 돌립니다. 일반적으로 사용되는 복구 방법은 다음과 같습니다.

- 프로세스 종료: 데드락에 연루된 프로세스 중 일부 또는 전부를 강제로 종료하고 이들이
  점유하고 있던 자원을 회수하여 다른 프로세스에 할당합니다.

- 자원 선점: 데드락에 연루된 프로세스들로부터 강제로 자원을 회수한 후 다른 프로세스에
  해당 자원을 할당합니다. 이 방법에서 주의할 점은 자원을 회수당한 프로세스가 적절한
  시기에 자원을 돌려주어야 한다는 것입니다.


### 무시(Ignoring)

데드락 무시는 데드락의 발생 빈도가 낮고 복구 비용이 높은 경우에 데드락 발생 가능성을
무시하는 방법입니다. 이 방법은 다음과 같은 상황에서 고려할 수 있습니다.

- 시스템 구조나 운영상 데드락 발생 확률이 매우 낮은 경우

- 데드락 발생이 큰 영향을 주지 않는 시스템인 경우(예: 데드락에 대응할 자원이나 시간이
  충분한 경우)

- 데드락에 대한 복구나 처리 비용이 시스템에 부담이 되는 경우

데드락 무시 전략이 적용되는 시스템에서는 주기적으로 데드락 상황을 모니터링하고 필요한 경우
관리자나 사용자가 수동으로 상황을 해결할수 있는 대응책을 갖추어야 합니다.

하지만 데드락 무시는 근본적인 해결책이 아니기 때문에 데드락 상황이 발생할 경우 시스템 성능
저하나 서비스 장애 위험이 증가 할 수 있습니다.


## 경쟁상태(Race Condition)

경쟁상태는 운영 체제에서 두개 이상의 스레드, 프로세스 또는 태스크가 공유 자원에 동시에
액세스하려고 할 때 발생하는 문제입니다. 이로 인해 실행 순서나 타이밍에 따라 결과가 달라
질 수 있습니다. 경쟁 상태는 일반적으로 올바른 결과가 나오지 않게 만들며 데이터 무결성에
위험이 될 수 있습니다.

경쟁상태를 해결하는 방법 중 하나는 공유 자원에 대한 액세스를 동기화하는 것입니다.
동기화 기법으로는 세마포어, 뮤텍스, 모니터 등이 있습니다. 이러한 기법들은 다중 스레드
프로세스, 태스크 간에 공유 자원에 한번에 하나의 엔티티만 액세스할 수 있도록 제한하여
경쟁상태를 방지합니다.


### 세마포어(Semaphore)

세마포어는 운영 체제 내에서 공유 자원에 대한 동시 접근을 관리하기 위해 사용되는
동기화 기법입니다. 세마포어는 주로 정수 값을 가진 변수로 표현되며 동시에 실행되는
프로세스나 스레드의 개수를 제어합니다. 세마포어는 두 가지 기본 연산으로 작동합니다.

- Wait: 세마포어 값을 감소시키는 연산입니다. 세마포어 값이 0보다 큰 경우
  연산을 수행하고 값을 1 감소시킵니다. 세마포어 값이 0인경우 대기 상태에 머물게 됩니다.

- Signal: 세마포어 값을 1 증가시키는 연산입니다. 대기 중인 프로세스나 스레드가 있다면
  그중 하나가 실행을 재개합니다.

세마포어를 사용하면 동시에 접근해야 하는 공유 자원에 대한 접근을 제어할 수 있습니다.
예를 들어 공유 자원이 3개의 프로세스에 의해 동시에 사용될 수 있는 경우 세마포어 값을
3으로 설정합니다. 이후 각 프로세스가 공유 자원에 접근하기 전에 Wait 연산을 호출하고
사용이 끝난 후에 Signal 연산을 호출합니다.

세마포어에는 두 가지 종류가 있습니다.

- 이진 세마포어: 0과 1의 값만 가지며 이는 기본적으로 뮤텍스와 동일한 기능을 제공합니다.
  이진 세마포어는 공유 자원에 하나의 프로세스나 스레드만 접근할 수 있도록 허용합니다.

- 계수 세마포어: 값을 누적할 수있는 세마포어로서 공유 자원을 동시에 여러 스레드나
  프로세스에 허용할 수 있습니다.


### 뮤텍스(Mutex)

뮤텍스는 세마포어와 마찬가지로 운영 체제 내에서 공유 자원에 대한 동시 접근을 관리하기
위해 사용되는 동기화 기법입니다. 공유 자원은 오직 하나의 스레드나 프로세스만 접근 할
수 있도록 합니다. 뮤텍스는 일반적으로 락(Lock)이라는 개념을 사용하여 작동합니다.
락은 공유 자원에 대한 액세스를 컨트롤하는 방법이며 프로세스나 스레드가 공유 자원을 
사용하기전에 락을 획득해야하고 자원 사용이 끝나면 락을 해제해야 합니다. 뮤텍스는 다음
과같은 연산으로 작동합니다.

- 락 획득(Lock or Acquire): 스레드나 프로세스가 공유 자원에 액세스하기 전에 호출 되는
  함수입니다. 뮤텍스가 이미 락 상태에 있으면 호출한 스레드나 프로세스가 대기열에 들어
  가게 됩니다.

- 락 해제(Unlock or Release): 스레드나 프로세스가 공유 자원 사용을 마치고 락을 해제하면
  대기 중인 다른 스레드나 프로세스들이 액세스할 수 있게 됩니다. 


세마포어와 뮤텍스는 여러 스레드나 프로세스에 대한 공유 자원에 동시 접근을 방지하고 경쟁상태를
방지할수 있지만 잘못 사용하면 교착상태와 같은 문제가 발생할 수 있으므로 주의해야합니다.


## 사용자/커널 수준 쓰레드

- [사용자_수준]
  커널에 의존적이지 않고 사용자가 라이브러리를 활용하는 방식을
  사용자 레벨 쓰레드라고 한다. 사용자 영역 쓰레드에서 행동하기 때문에
  Context Switching이 없고 커널 쓰레드보다 오버헤드가 적다.
  하지만 시스템 전반에 걸친 스케줄링 우선순위를 지원하지 않고
  프로세스에 속한 쓰레드 중 하나라도 블록되면 전체가 블록된다.

- [커널_수준]
  스케줄링을 하는 주체가 커널일때 커널 레벨 쓰레드라고 한다.
  커널 쓰레드는 각 쓰레드를 개별적으로 관리할수 있고 멀티프로세서 환경에
  유리하다. 하지만 멀티 프로세서를 위한 Context Switching에 따른
  오버헤드를 고려해야하고 커널 모드와 사용자 모드의 전환이 빈번하게 이루어져
  성능 저하가 발생 할 수있다.