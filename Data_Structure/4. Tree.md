# Tree
======

트리는 노드들이 나무 가지처럼 연결 된
비선형 계층적 자료구조이다.
부모 노드에 자식 노드가 연결되고 자식 노드에 각각
자식 노드가 연결되는 재귀적 형태의 자료구조다.


## 특징

- 데이터를 순차적으로 저장하지 않기 때문에 비선형이다.

- 트리내에 또 다른 트리가 있는 재귀적 자료구조이다.

- 모든 자식노드는 하나의 부모 노드만 갖는다.

- 노드가 n개인 이진 트리는 항상 n-1개의 간선(Edge)을 가집니다.


## 용어

- 노드 (Node) : 트리를 구성하는 기본요소

- 간선 (Edge) : 노드와 노드간의 연결 선

- 루트 노드 (Root Node) : 부모가 없는 최상위 노드

- 부모 노드 (Parent Node) : 자식 노드를 가진 노드

- 자식 노드 (Child Node) : 부모 노드의 하위 노드

- 형제 노드 (Sibling Node) : 같은 부모를 가진 노드

- 외부 노드 (External Node), 리프 노드 (Leaf Node) : 자식이 없는 노드

- 내부 노드 (Internal Node) : 자식이 하나 이상 있는 노드

- 깊이 (Depth) : 루트에서 어떤 노드까지의 간선 수

- 높이 (height) : 어떤 노드에서 리프 노드까지의 가장 긴 경로의 간선의 수


## 편향 트리

모든 노드들이 자식을 하나만 가진트리,
왼쪽으로만 자식을 가질때 left shew tree,
오른쪽으로만 가질때 right skew tree 라고한다.


## 이진 트리

부모 노드 밑의 자식 노드 개수를 최대 2개로 제한하는 트리의 가장 간단한 형태
대부분의 트리는 보통 이진트리로 구현된다.


### 정(Full Binary) 이진 트리
  
모든 트리의 자식은 0개 이거나 2개이다.


### 포화(Perfect) 이진 트리

모든 리프 노드의 높이가 같고 리프 노드가 아닌 노드는 모두 2개의 자식을 갖는다.
이진 트리에서 높이가 n일때 가장 많이 존재할 수 있는 노드의 수는 2**n-1개인데
포화 이진 트리는 이 개수를 모두 채운 이진 트리이다. 또한 모든 포화 이진 트리는
정 이진 트리이다.


### 완전(Complete) 이진 트리

모든 리프 노드의 높이가 최대 1차이가 나고 모든 노드의 오른쪽 자식이 있으면
왼쪽 자식이 있는 이진 트리이다. 다시 말해 트리의 원소를 왼쪽에서 오른쪽으로
하나씩 빠짐없이 채워나간 형태이다. 포화 이진 트리는 완전 이진 트리의 부분집합이다.
포화 이진트리가 아닌 완전 이진 트리는 정 이진 트리일 수도있고 아닐 수도 있다.


## 이진 탐색 트리 (Binary Search Tree)

이진 트리의 일종으로, 노드의 왼쪽 가지에는 노드의 값보다 작은 값만들만 있고
오른쪽 가지에는 큰 값만 있도록 구성되어 있다. 자식 노드들도 동일한 방법으로
정렬되어 어떤 노드를 잡아도 동일한 규칙으로 정렬되어 있다. 그러므로
트리가 이진 탐색하기에 적합한 구성이 되게 된다.
다만, 1부터 순서대로 삽입하게 될 경우 오른쪽으로만 삽입되어 이진 탐색 트리의
장점을 잃고 선형 탐색과 다를게 없게 되고 편향 트리가 될 수 있는 단점이 있다.


## Red-Black Tree

이진 탐색 트리의 일종으로, 노드에 색상이 들어간 형태의 트리이다.
이진 탐색 트리의 단점을 보완해서 시간 복잡도를 O(log N)으로 최적화 시킨 트리이다.
자식이 하나도 없는 노드 끝에는 널 리프 노드라는 것을 붙여 트리의 끝을 표현한다.

- 모든 노드는 레드 노드 혹은 블랙 노드이다.
- 루트 노드는 블랙 노드이다.
- 모든 널 리프 노드는 블랙 노드이다.
- 레드 노드의 자식 노드는 언제나 블랙 노드이다.
- 임의의 한 노드에서 널 리프 노드까지 도달하는 모든 경로에는 항상 같은 수의
  블랙 노드가 있다.
- 블랙 노드는 연속해서 나올수 있지만 레드 노드는 그렇지 않다.
- n개의 내부 노드를 갖는 Red-Black Tree의 높이는 2log(n+1)이하 이다.


## Heap

여러 개의 값 중에서 가장 크거나 작은 값을 빠르게 찾기 위해 만든 이진 트리,
힙은 항상 완전 이진 트리 형태를 띄어야 한다.
보통의 경우 우선순위 큐를 구현하거나 힙 정렬을 만드는 등의 일을 할 수있다.
그리고 이진 탐색 트리에서는 중복된 값을 허용하지 않지만 힙 트리에서는
허용한다.

- 최대 힙 (max heap)
  부모의 키 값이 자식의 키 값보다 크거나 같은 완전 이진 트리

- 최소 힙 (min heap)
  부모의 키값이 자식의 키 값보다 작거나 같은 완전 이진 트리


힙을 저장하는 표준적인 자료구조는 배열이다.
편의를 위해 인덱스는 1부터 사용한다.
특정 위치의 노드 번호는 새 노드가 추가되어도 변하지 않는다.

부모의 인덱스 = 자식의 인덱스 / 2
왼쪽 자식의 인덱스 = 부모의 인덱스 * 2
오른쪽 자식의 인덱스 = 부모의 인덱스 * 2 + 1

## B-tree

이진 트리를 확장한 형태로 노드에는 2개 이상의 데이터가 들어갈 수 있고
항상 정렬된 상태로 저장되며 자식 노드를 2개 이상을 가질수 있고 최대 M개
의 자식을 가질 수 있는 B트리를 M차 B트리라고 한다.
노드 내에 데이터는 floor(M/2)-1개부터 최대 M-1개 까지 들어갈 수 있다.
특정 노드의 데이터가 K개라면 자식 노드의 개수는 K+1개여야 한다.
특정 노드의 왼쪽 서브트리는 특정 노드의 키보다 작은 값들로,
오른쪽 서브트리는 큰값들로 구성 되며 a1, a2 사이의 서브 트리는 a1 보다는
크면서 a2보다는 작아야 한다. 모든 리프 노드들은 같은 레벨에 존재한다.

방대한 양의 자료를 검색해야 하는경우, 검색어와 자료를 일일이 비교하는 방식은
비효율적이다. 노드에 접근하는 시간이 노드에서 연산하는 시간보다 훨씬 길 경우
B-tree를 쓰는것이 유리하다. 자식 노드가 가질수 있는 수를 늘이고 트리의 높이를
줄여서 노드에 접근하는 횟수를 줄일 수 있기 때문이다.
주로 데이터 베이스나 파일 시스템 등에서 사용 된다.


## B+ tree

B-tree의 확장형이다. 루트 노드와 중간 노드는 키를 이용하여 위치를 찾아가는
인덱스 역할만을 하고 데이터 자체는 모두 리프 노드에 저장한다.
데이터를 정렬하여 리프 노드에 저장하고 그 위는 B-tree의 규칙으로 키를 저장해
트리를 구성하는 방식이다. 이때 리프 노드는 이중 연결 리스트로 구성하여
순차적으로 검색하기 용이하도록 한다.


## 이진 트리의 순회 방법

- 중위 순회(in-order traversal) : 왼쪽 자식, 자신, 오른쪽 자식 순서로
  순회하는 방법, 이진 탐색 트리를 중위 순회하면 정렬된 결과를 얻을수 있다.

- 전위 순회(pre-order traversal) : 자신, 왼쪽 자식, 오른쪽 자식 순서로
  순회하는 방법

- 후위 순회(post-order traversal) : 왼쪽 자식, 오른쪽 자식, 자신 순서로
  순회하는 방법

- 레벨 순서 순회(level-order traversal) : 너비 우선 순회라고도 한다. 노드를
  레벨 순서로 방문하는 순회방법


위의 세가지 방법은 스택으로 구현할 수 있는 반면 레벨 순서 순회는 큐를 활용해
구현할 수 있다.


## 사용 예시

- 윈도우 디렉터리

- 힙

- 데이터 베이스 인덱싱


Refenence :
https://namu.wiki/w/%ED%8A%B8%EB%A6%AC(%EA%B7%B8%EB%9E%98%ED%94%84)#s-4
https://yoongrammer.tistory.com/68
https://namu.wiki/w/%ED%9E%99%20%ED%8A%B8%EB%A6%AC
https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html
https://ko.wikipedia.org/wiki/B_%ED%8A%B8%EB%A6%AC
https://code-lab1.tistory.com/217
https://foramonth.tistory.com/47