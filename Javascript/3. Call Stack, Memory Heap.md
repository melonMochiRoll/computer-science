# Call Stack, Memory Heap
======

## 원시 데이터 타입
- Number
- String
- Boolean
- Null
- Undefined
- Bigint
- Symbol

## 콜스택(Call Stack)
  원시타입 데이터가 저장된다.
  실행컨텍스트를 통해
  - 변수 저장
  - 스코프 체인 및 this 관리
  - 함수 호출 순서 관리를 수행

## 참조 데이터 타입
- Object
- Array (typeof array === object)
- Function

## 메모리 힙(Memory Heap)
  참조타입(객체, 함수 등) 데이터가 저장된다.

- [원시타입_변수_생성]
  let a = 10;

  10이라는 값 자체는 원시타입이므로 콜스택에 저장된다.
  변수 a에는 10이 저장된 콜스택 메모리의 주소값이 저장된다.
  변수 a는 실행 컨텍스트가 생성됐을때 변수객체에 저장된다.

- [원시타입_재할당]
  a = 20;

  a에 20을 재할당하면
  기존에 20을 저장하고있는 메모리 주소값이 있는경우
  변수 a에 10이 메모리 주소값이 20의 주소값으로 교체된다.

  기존에 메모리에 저장된 값이 없는 경우
  새로운 메모리를 확보하여 30을 저장하고 그 주소값으로 교체된다.

- [참조타입_변수_생성]
  const b = [1, 2, 3];

  배열, 객체, 함수 등은 참조타입이므로 메모리 힙에 저장된다.
  참조타입 데이터가 저장된 메모리힙의 주소값은 콜스택에 각각 저장된다.
  메모리힙의 주소값이 저장된 콜스택의 주소값은 변수 b에 저장된다.

- [참조타입_데이터_변경]
  b.push(4);

  메모리 힙에 저장된 배열의 값을 변경하더라도
  배열이 저장된 메모리 힙의 주소는 그대로다.

- [참조타입_재할당]
  b = [100, 200, 300];

  이 경우, 메모리 힙에 새로운 주소가 확보되고
  새로운 배열이 저장된다.

  콜스택에 저장되는 메모리힙의 주소값도 새로운 주소로 변경된다.
  콜스택도 기존에 저장되어 있던 주소값을 바꾸는게 아니라
  새로운 메모리를 확보해서 새로운 메모리 힙의 주소값을 저장한다.

  따라서 변수 b에 저장되는 콜스택의 주소값도 변경된다.

- [동일한_구성의_참조타입_데이터]
  const c = {
    name: 'john'
  };
  const d = {
    name: 'john'
  };

  객체와 같은 참조타입 데이터는 동적으로 내부 요소가 변경될 수 관계로
  동일한 요소의 객체를 생성하더라도 메모리 힙에 각각 별도의 메모리 공간을
  확보하여 저장된다.

  c !== d

## 가비지 컬렉터
  더이상 참조되지 않는 데이터는 가비지 컬렉터에 의해
  적절한 시점에 메모리에서 해제된다.


Reference :
https://curryyou.tistory.com/276
https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/javascript/stack-heap.md