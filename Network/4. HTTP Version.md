# HTTP Version
======

## 1.0과 1.1의 차이

### 연결 지속성

HTTP는 기본적으로 TCP를 이용해 통신한다.
이때 1.0은 TCP 세션을 유지하지 않고
1.1는 TCP 세션을 유지할 수 있다는 차이점이 생긴다.

1.0은 매번 데이터를 요청하고 수신할 때 마다 새로운 TCP 세션을
맺어야 한다. 반면 1.1은 한번의 TCP 세션에 여러 개의 요청을 보내고
응답을 수신할 수 있다.

이로인해 1.1은 TCP세션 처리 부하를 줄이고 응답속도를 개선할 수 있다.

### 파이프라이닝(Pipelining)

1.0은 파이프라이닝을 제공하지 않고
1.1은 파이프라이닝을 제공한다.

즉, 1.0은 1번 요청을 보내고 1번 응답을 받아야지 2번 요청을
보내는 식으로 동작한다.
하지만 1.1은 여러 개의 요청을 동시에 보낼 수 있다.

### 호스트 헤더

1.0은 하나의 IP주소에 여러 개의 도메인을 운영 할 수 없었다.
따라서 도메인 별로 IP를 구분해서 준비해야 하기 때문에
서버의 개수가 늘어나야 했다. 하지만 1.1은 가상 호스팅이
가능해졌기 때문에 하나의 IP주소에 여러 개의 도메인을 적용
시킬수 있다.

### 향상된 인증 절차

1.1에서는 2개의 헤더가 추가 되었다.

proxy-authentication
proxy-authorization

실제 서버에서 클라이언트 인증을 요구하는 헤더는 1.0에도
지원했으나 서버와 클라이언트 사이에 프록시가 위치하는 경우
사용자의 인증을 요구할 수 있는 방법이 없었다.
그러나 위와 같은 헤더의 추가로 프록시가 사용자의 인증을
요구하는게 가능해졌고 인증 절차가 향상되었다.

## HTTP/1.1의 결점

원칙적으로는 1개의 요청이 완료될 때 까지 다음 요청을 보낼 수 없었다.
1.1에서는 이러한 제약을 연결 지속성과 파이프라인을 도입하여 이 문제를
해결한다. 데이터를 요청할 때마다 새로운 TCP 세션을 맺을 필요 없이
세션이 유지가 되었고 이를 통해 클라이언트는 동일한 연결을 통해 여러 요청을
각각 응답을 기다리지 않고 전송할 수가 있었다.

하지만 이러한 전략에도 피할수 없는 병목현상이 존재했다. 동일한 대상으로
이동할 때 여러 데이터 패킷이 동시에 통과할 수 없기 때문에 대기열 앞에
있는 요청들이 [대기_상태(Head_Of_Line_Blocking)]가 되어 성능 저하 현상이 발생하게 된다.

## 결점을 극복하기 위한 노력

- 이미지 스프라이트: 웹 페이지를 구성하는 이미지 파일들의 요청 횟수를
  줄이기 위해 하나의 큰 이미지 파일로 만들고 해당 이미지의 좌표 값을
  지정하여 표시하는 방법
  (요청 수를 줄일수 있지만 스프라이트 처리에 리소스 소모)

- 도메인 샤딩: 여러 개의 Connection을 생성해서 병렬로 요청을 보냄
  하지만 브라우저 별로 도메인당 Connection 개수 제한이 존재하기 때문에
  근본적인 해결을 어렵고 그 만큼의 비용이 든다.

- 웹 글꼴 사용: 요청 수를 줄일수 있음

## HTTP/2.0

2015년 IETF의 의해 발표된 HTTP/1.1의 후속 버전이다.
구글의 SDPY프로토콜의 기반으로 1.1의 문제점을 개선하기 위해
HTTP/2.0이 등장하게 된다.

### HTTP/2.0의 주요 기능

- [스트림의_다중화(Multiplexed_Streams)]
  1.1에서는 요청과 응답을 1개씩 밖에 송수신 할수 밖에없어
  병목현상이 일어날수 있었지만 2.0에서는 하나의 Connection상에서
  병렬로 송수신할 수있어 파이프라인 문제를 해결할 수 있다.

- [스트림의_우선도(Stream_Prioritizaion)]
  리소스 간의 우선 순위를 부여해 성능을 최적화하고
  중요 스트림의 반환을 앞당길수 있게 되었다.

- [헤더_압축(Header_Compression)]
  헤더 정보를 HPACK 방식으로 압축해 헤더에 중복이 있는경우
  중복을 검출해 내고 HTTP 메세지의 크기를 줄일수 있다.

- [서버_푸쉬(Server_Push)]
  클라이언트는 초기 GET 요청으로 부터 응답을 받은 후에만
  추가 리소스가 필요하다는 것을 알수 있으므로 페이지를 완성하기
  위해 추가 요청을 해야한다. 따라서 이는 연결 로드 시간을 증가시켰다.
  
  1.1에서는 서버가 초기 GET에 응답하여 보내는 HTML 문서에 직접
  필요한 리소스를 포함해서 보내줄 수 있다. 이러한 리소스 인라이닝은
  클라이언트가 보내야하는 요청수를 줄일 수 있지만 용량이 큰 파일이
  포함될 경우 HTML 문서의 크기를 증가시켜 연결 속도가 감소되어
  이점이 상쇄 되어 버린다.

  2.0은 클라이언트 초기 GET 요청에 대해 동시 응답을 허용하므로
  서버는 요청한 HTML 페이지와 함께 클라이언트에 리소스를 전송하여
  클라이언트가 요청하기 전에 리소스를 제공할 수 있다.


Reference :
HTTP/1.1
https://code-lab1.tistory.com/196
https://code-lab1.tistory.com/19
https://code-lab1.tistory.com/27

HTTP/2
https://nouljotne.tistory.com/7
https://yceffort.kr/2021/05/http1-vs-http2
https://velog.io/@wiostz98kr/HTTP1.1%EA%B3%BC-HTTP2.0%EC%9D%98-%EC%B0%A8%EC%9D%B4-e2v4x4t1