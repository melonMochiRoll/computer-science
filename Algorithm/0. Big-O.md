# Big-O
======

## 시간 복잡도

시간 복잡도란 어떠한 알고리즘이 실행되는데 걸리는 시간을 의미하며
주요 로직의 반복 횟수를 중점적으로 측정됩니다.

시간복잡도를 고려한, 효율적인 알고리즘은 입력값이 커짐에 따라
증가하는 시간의 비율을 최소화한 알고리즘이라고 말할수 있습니다.
이 시간복잡도는 주로 Big-O 표기법을 사용해 나타냅니다.

## Big-O 표기법

10n^2 + n

이를 Big-O표기법으로 나타내면 O(n^2)라고 할수 있습니다.

Big-O표기법은 복잡도에 가장 많은 영향을 끼치는 항의 상수인자와
나머지 항을 없애서 나타내는 표기법입니다.

일반적인 순회를 할때와 같이 찾는 값이 맨 앞에 있다면 O(1)일수
있겠지만 맨 끝에 있다면 O(n)이 될수도 있습니다. 이때처럼 구간마다
효율이 다르더라도 Big-O표기법은 최악을 상정합니다.

Big-O의 복잡도 레벨은 다음과 같이 나타낼수 있습니다.

- Horrible

O(n!) > O(2^n) > O(n^2)

- Bad

O(n log n)

- Fair
  
O(n)

- Good

O(log n) > O(1)


### 일정 복잡도 O(1)

입력값과 상관없이 일정한 시간복잡도를 가지는 것을 말합니다.
더하기 빼기 등의 사칙연산, 간단한 비교문, 배열의 인덱스 참조 등이
여기에 해당됩니다.


### 로그 복잡도 O(log n)

O(log n)은 O(1) 다음으로 빠른 시간 복잡도를 가집니다.
입력값이 늘어남에 따라 시간은 점차 줄어듭니다.
대표적으로 BST와 같은 이진탐색이 O(log n)에 해당합니다.


### 선형 복잡도 O(n)

입력값이 증가함에 따라 같은 비율료 증가하는 것을 말합니다.

입력값이 1일때 1초가 걸리고 100배 증가했을때 100초가 걸린다면
이 알고리즘은 O(n)의 시간 복잡도를 가졌다고 할수 있습니다.

- O(n)의 시간 복잡도를 가진 알고리즘

for (let i=0; i<=n; i++) {
  console.log(i);
}

for (let i=0; i<=2n; i++) {
  console.log(i);
}

두번째 for문의 경우 2n이라고 착각할수 있지만 입력값이 커질수록
n앞의 계수가 점점 퇴색되기 때문에 같은 비율로 증가한다면
O(n)으로 표기합니다.


### 2차 복잡도 O(n^2)

입력값이 증가함에 따라 그 비율이 제곱으로 증가하는 것을 말합니다.

- O(n^2)의 시간 복잡도를 가진 알고리즘

for (let i=0; i<=n; i++) {
  for (let j=0; j<=n; j++) {
    console.log(i + j);
  }
}


### 기하급수적 복잡도 O(2^n)

기하급수적 복잡도는 Big-O표기법 중 가장 느린 축에 속합니다.
재귀로 구현한 피보나치 수열은 이에 해당하는 대표적인 알고리즘입니다.


Reference :  
https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-time-complexity-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/  
https://m.blog.naver.com/PostView.naver?blogId=jhc9639&logNo=222283814653&referrerCode=0&searchKeyword=Prefix