# BFS, DFS
======

## 너비 우선 탐색 (Breadth First Search)

임의 노드에서 인접한 노드부터 먼저 순회하는 방법
최소 비용 혹은 임의의 경로를 찾고 싶을때 적합하다.
보통 큐를 이용해 구현한다.

- 시간 복잡도 (정점의 수 : N, 간선의 수 : E) 
  인접 리스트 : O(N+E)
  인접 행렬 : O(N^2)

그래프 내에 적은 숫자의 간선을 가지는 희소 그래프의 경우
인접 행렬보다 인접 리스트로 구현하는 것이 적합하다.


### 특징

- DFS보다 구현이 좀더 복잡하다.

- 노드의 수가 적고 깊이가 얕은 경우 빠르게 순회할 수있다.

- 너비를 우선 탐색하므로 최단 경로를 보장한다.


### 과정

- 시작 노드을 순회하고 큐에 넣는다.

- 큐에서 가장 앞 노드를 빼고 큐에서 꺼낸 노드와 인접한
  노드들을 모두 차례로 방문한다.

- 인접한 노드가 없다면 큐 앞에서 노드를 꺼낸다.

- 큐가 소진될 때까지 반복한다.


## 깊이 우선 탐색 (Depth First Search)

임의 노드에서 다음 분기로 넘어가기 전, 해당 분기를
모두 순회하는 방법
모든 경로를 방문해야 할 경우 적합하다.
보통 스택 or 재귀함수를 통해 구현한다.

- 시간 복잡도 (정점의 수 : N, 간선의 수 : E)
  인접 리스트 : O(N+E)
  인접 행렬 : O(N^2)

그래프 내에 적은 숫자의 간선을 가지는 희소 그래프의 경우
인접 행렬보다 인접 리스트로 구현하는 것이 적합하다.


## 특징

- BFS보다 구현이 간단하다.

- 목표가 깊은 단계에 있을 경우 적합하다.


## 과정

- 시작 노드를 순회하고 스택에 추가한다.

- 이후 스택 맨 앞 노드인 A의 인접 노드인 B를 방문하고
  스택에 추가한다. (순서는 상관 없음)

- B의 인접 노드인 D를 방문하고 스택에 D를 추가한다.

- D의 인접 노드가 없다면 D를 스택에서 제거한다.

- 다시 B의 인접 노드인 E를 방문하고 스택에 E를 추가한다.

- B의 분기를 전부 탐색했다면 시작 노드의 이웃 노드를 방문한다.

- 스택이 소진될 때까지 반복한다.


Reference :
https://gyoogle.dev/blog/algorithm/DFS%20&%20BFS.html
https://code-lab1.tistory.com/15
https://code-lab1.tistory.com/16
https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html
https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html