# Transaction
======

트랜잭션이란 DB의 상태를 변화시키기 위해 수행하는
작업의 단위또는 한꺼번에 수행되어야할 일련의 연산들을 뜻한다.

논리적인 작업 단위를 모두 완벽하게 처리하거나 또는 처리하지
못했을경우에 원 상태로 복구해서 아무것도 적용되지 않음을
보장하는 기능이다.

SELECT, UPDATE, INSERT, DELETE와 같이 DB의 상태를
변화시키는 작업의 단위이다.


## 특징 - ACID

- [Atomicity(원자성)]
  트랜잭션이 모두 반영되거나 전혀 반영되지 않아야한다.

- [Consistency(일관성)]
  트랜잭션의 작업 처리 결과는 항상 일관적이어야 한다.

- [Isolation(독립성)]
  둘 이상의 트랜잭션이 실행되고 있을때 서로 다른 트랜잭션 연산에
  간섭할 수 없다.

- [Durability(지속성)]
  트랜잭션이 성공적으로 되었다면 영구적으로 반영되어야 한다.


## Commit, Rollback

- [Commit]
  Commit 연산은 하나의 트랜잭션이 성공적으로 완료되었고
  DB가 일관성 있는 상태일때 이를 알려주기 위한 연산이다.

- [Rollback]
  Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어
  원자성이 깨졌을때 트랜잭션의 원자성을 지키기위해 트랜잭션의
  작업을 모두 취소하는 연산이다.


## 격리 수준(Isolation Level)

격리 수준이란 트랜잭션에서 일관성 없는 데이터를 허용하는 수준을 말한다.

DB는 트랜잭션의 독립적 수행을 위해 Locking 기법을 통한 관리가 필요한데
고립 정도를 높인다면 성능은 떨어지고 고립 정도를 너무 줄여 동시성을 높이면
무결성에 문제가 발생할 가능성이 증가하여 적절한 기법 사용이 요구된다.


## 격리 수준 종류

- [Read_Uncommitted] - 레벨 0
  트랜잭션이 처리중이거나 아직 Commit되지 않은 데이터에 다른 트랜잭션의
  데이터 조회가 가능하다.
  
  데이터 정합성에 문제가 발생할 가능성이 높다.
  격리 수준으론 인정되지 못함

- [Read_Committed] - 레벨 1
  어떤 트랜잭션이 Commit되어야만 다른 트랜잭션에서 조회할 수 있다. 
  Commit되기 전 조회시 UNDO 영역에 있는 백업된 값을 조회하게 되는데
  Commit 된 후엔 트랜잭션 내에서 같은 두 쿼리의 결과값이 달라질수 있는
  Non Repeatable Read 문제가 발생할수 있다.
  
  Oracle을 포함한 대부분의 SQL 서버에서 Default 값이다. 

- [Repeatable_Read] - 레벨 2
  트랜잭션이 시작되기 전, Commit된 내용에서만 조회할 수있는 격리수준이다.
  트랜잭션이 범위 내에서 조회한 데이터가 항상 동일함을 보장한다.
  다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정/삭제가
  불가능하다.
  자신의 트랜잭션 ID보다 낮은 트랜잭션에서 변경된 것만 읽게 되고
  자신의 트랜잭션 ID보다 높은 트랜잭션에서 변경된 것은 UNDO 영역에서
  백업된 값을 조회하게 된다.

  Non Repeatable Read 문제는 해결되지만 삽입은 여전히 가능하기 때문에
  Phantom Read 문제가 발생할 수 있다.

  MySQL의 Default 값이다.

- [Serializable] - 레벨 3
  가장 엄격한 격리 수준이다.
  트랜잭션 영역에 해당되는 데이터에 수정/삭제/삽입이 불가능하다.
  동시 처리 능력이 떨어져 성능 저하가 발생한다.

  Dirty Read, Non Repeatable Read, Phantom Read 문제가 발생하지 않는다.


## 격리 수준에 따른 주요 문제점

- [Dirty_Read] :
  커밋되지 않은 트랜잭션에서 수정중인 데이터의 변경 사항을 다른 트랜잭션에서
  읽었을때 발생하는 현상

- [Non_Repeatable_Read] :
  한 트랜잭션이 같은 쿼리를 2번 실행 할때 그 사이 다른 트랜잭션이 해당 
  데이터를 수정/삭제하여 같은 쿼리의 결과 값이 다른 현상

- [Phantom_Read] :
  한 트랜잭션이 같은 쿼리를 2번 실행 할때 그 사이 다른 트랜잭션이 해당 영역에
  레코드를 추가하여 같은 쿼리의 결과 값이 다른 현상


Reference :
https://code-lab1.tistory.com/51
https://code-lab1.tistory.com/52
https://gyoogle.dev/blog/computer-science/data-base/Transaction.html